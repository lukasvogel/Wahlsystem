\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\author{Raul Persa, Lukas Vogel}
\title{Voting Process}
\begin{document}
\maketitle

\section*{Outline}
\begin{itemize}
	\item The voter enters the Wahllokal
	\item The Wahlhelfer hands the voter a valid token for the current Wahlkreis and election. 
		He also enters into the system that the voter has been issued a token
		\begin{itemize}
			\item If no token is remaining: 
			\begin{itemize}
				\item The Wahlhelfer generates a new batch of tokens using his credentials.
			\end{itemize}
			\item If the voter has already been issued a token (i.e. he already voted):
			\begin{itemize}
				\item The Systems warns the Wahlhelfer. The voter is given a stern talking to and is sent away.
			\end{itemize}
		\end{itemize}
		

	\item The voter enters a free Wahlkabine and enters his token and votes.
		\begin{itemize}
			\item If the sent data is invalid (invalid token, 
			voting for a candidate not running in the current Wahlkreis or election, 
			voting for a party not running in the election, 
			generally trying to manipulate the system 
			by sending his own POST-requests with manipulated data, HUMAN ERROR, VOTER):
				\begin{itemize}
					\item The user is at fault: 
					The System urges the user to check the entered data and retry
				\end{itemize}
		\end{itemize}

	\item The System registers the vote and invalidates the token in a single transaction.
		\begin{itemize}
			\item If the commit fails 
			(token was used by other voter between first consistency check of vote and commit 
			of the voting-transaction, HUMAN ERROR, WAHLHELFER):
				\begin{itemize}
					\item User is notified that an internal problem has happened and
					 he should notify the Wahlhelfer
					\item After checking the system state, 
					the wahlhelfer issues the voter a new token
			\end{itemize}
	\end{itemize}
\end{itemize}

\section*{Implementation}

\paragraph*{}
The voting service is reachable at \\
\texttt{http://votingserver/wahl/electionID/wahlkreisID}. \\
In an actual production environment the server would not be reachable from the internet but only by VPN or something equally secure. The actual voting is done by sending a POST-REQUEST to \\ \texttt{http://votingserver/wahl/electionID/wahlkreisID/vote}. \\
The fields \texttt{token}, \texttt{erststimme} and \texttt{zweitstimme} have to be set. \texttt{erststimme} and \texttt{zweitstimme} are the IDs of a candidate / a party. 

On the actual voting machine a stripped-down browser only pointing to \texttt{/wahl/eid/wkid} could be used as frontend. If this is deemed to insecure and / or resource-intensive an own fronted could be developed sending the right HTTP POST-Requests to the voting server.

\paragraph*{}
The server is hardened against SQL-Injections: All user input is escaped properly by using the proper string-building functions of the psqcopg2-python-module.

Manipulation by sending rogue-POST-requests is also impossible. Each issued token is internally associated with an election and a Wahlkreis. Thus a voter can't use his token to vote in another wahlkreis or election. The handling of a single vote is done in one transaction. This guarantees that the database cannot be in an inconsistent state (i.e. voted but token not invalidated).

\end{document}